package osp.leobert.android.davinci.apt

import com.google.auto.service.AutoService
import com.squareup.kotlinpoet.*
import osp.leobert.android.davinci.annotation.DaVinCiStyle
import osp.leobert.android.davinci.annotation.DaVinCiStyleFactory
import osp.leobert.android.davinci.annotation.StyleViewer
import osp.leobert.android.davinci.meta.PreviewConfigMetaInfo
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.TypeElement
import javax.lang.model.util.Types
import javax.tools.Diagnostic

/**
 * <p><b>Package:</b> osp.leobert.android.davinci.apt </p>
 * <p><b>Project:</b> DaVinCi </p>
 * <p><b>Classname:</b> StyleProcessor </p>
 * Created by leobert on 7/9/21.
 */
@AutoService(Processor::class)
@SupportedAnnotationTypes(value = [
    "osp.leobert.android.davinci.annotation.StyleViewer",
])
public class StylePreviewProcessor : AbstractProcessor() {


    public lateinit var processingEnv: ProcessingEnvironment

    private lateinit var filer: Filer

    private lateinit var messager: Messager

    private lateinit var typeUtils: Types

    private val verbose by lazy {
        processingEnv.options["daVinCi.verbose"]?.toBoolean() == true
    }

    private val packageName by lazy {
        processingEnv.options["daVinCi.pkg"]
    }

    private val moduleName by lazy {
        processingEnv.options["daVinCi.module"]
    }

    private val preview by lazy {
        processingEnv.options["daVinCi.preview"]?.toBoolean() == true
    }


    private fun log(message: String) {
        if (verbose) {
            messager.printMessage(Diagnostic.Kind.NOTE, "[DaVinCi-apt]:$message\r\n")
        }
    }

    private fun logE(message: String, node: Element?) {
        messager.printMessage(Diagnostic.Kind.ERROR, "[DaVinCi-apt]:$message\r\n", node)
    }

    override fun init(processingEnv: ProcessingEnvironment?) {
        super.init(processingEnv)
        this.processingEnv = requireNotNull(processingEnv)

        this.filer = this.processingEnv.filer
        this.messager = this.processingEnv.messager
        this.typeUtils = this.processingEnv.typeUtils

        this.processingEnv.options
    }

    override fun process(
        annotations: MutableSet<out TypeElement>?,
        roundEnv: RoundEnvironment?,
    ): Boolean {
        processStyleViewer(annotations, roundEnv)
        return false
    }

    private fun processStyleViewer(
        annotations: MutableSet<out TypeElement>?,
        roundEnv: RoundEnvironment?,
    ) {

        annotations ?: return
        roundEnv ?: return


        val notatedElements = roundEnv.getElementsAnnotatedWith(StyleViewer::class.java)
            ?.filterIsInstance<TypeElement>()


        if (notatedElements.isNullOrEmpty()) {
            log("@StyleViewer not found")
            return
        }

        val configsProviders: MutableMap<String, PreviewConfigMetaInfo> = mutableMapOf()

        handleDaVinCiStyle(elements = notatedElements, configsProviders)
        generateAndClearConfigFiles(configsProviders)
    }


    private fun handleDaVinCiStyle(
        elements: List<TypeElement>,
        configsProviders: MutableMap<String, PreviewConfigMetaInfo>,
    ) {
        elements.forEach { style ->
            val annotation = style.getAnnotation(StyleViewer::class.java)

            val styleNotation = style.getAnnotation(DaVinCiStyle::class.java)
            val factoryNotation = style.getAnnotation(DaVinCiStyleFactory::class.java)

            val styleName: String = styleNotation?.styleName ?: factoryNotation?.styleName ?: run {
                logE("@StyleViewer annotation must used with @DaVinCiStyle or @DaVinCiStyleFactory ",
                    style)
                return
            }

            configsProviders[styleName] = PreviewConfigMetaInfo(
                styleName = styleName,
                width = annotation.width,
                height = annotation.height,
                background = annotation.background,
                type = annotation.type
            )
        }
    }

    private fun generateAndClearConfigFiles(configsProviders: MutableMap<String, PreviewConfigMetaInfo>) {

        val daVinCiStylesSpec =
            TypeSpec.objectBuilder("${moduleName ?: ""}DaVinCiStylePreviewInjector")
                .addKdoc(
                    CodeBlock.of("auto-generated by DaVinCi, do not modify")
                ).apply {
                    this.addFunction(
                        FunSpec.builder("register")
                            .addKdoc("register preview configurations")
                            .addModifiers(arrayListOf(KModifier.PUBLIC))
                            .addCode(
                                """
                               registerConfigs()
                            """.trimIndent()
                            )
                            .build()
                    )
                    this.addFunction(
                        FunSpec.builder("registerConfigs")
                            .addModifiers(arrayListOf(KModifier.PRIVATE))
                            .apply {
                                if (preview) {
                                    configsProviders.forEach {
                                        this.addCode(it.value.registerBlock())
                                    }
                                } else {
                                    this.addComment("not preview mode, ignore")
                                }
                            }

                            .build()
                    )


                }
                .build()
        val fileSpec = FileSpec.get(packageName ?: "", daVinCiStylesSpec)

        fileSpec.writeTo(filer)

    }

    override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latestSupported()

}